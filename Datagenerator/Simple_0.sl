/*
** Copyright (c) 2011 PIXAR.  All rights reserved.  This program or
** documentation contains proprietary confidential information and trade
** secrets of PIXAR.  Reverse engineering of object code is prohibited.
** Use of copyright notice is precautionary and does not imply
** publication.
**
**                      RESTRICTED RIGHTS NOTICE
**
** Use, duplication, or disclosure by the Government is subject to the
** following restrictions:  For civilian agencies, subparagraphs (a) through
** (d) of the Commercial Computer Software--Restricted Rights clause at
** 52.227-19 of the FAR; and, for units of the Department of Defense, DoD
** Supplement to the FAR, clause 52.227-7013 (c)(1)(ii), Rights in
** Technical Data and Computer Software.
**
** Pixar
** 1200 Park Ave
** Emeryville, CA 94608
**
** ----------------------------------------------------------------------------
*/

/* code generated by slim 10.5b1 (<unknown_buildid> Jul 30 2013) */
/* for wlw@plundarr.pixar.com at: Mon Sep 09 09:09:01 AM PDT 2013 */
/* shader modification timestamp: 1375921529 */


/* Slim interface meta data
 *
<meta id="slim"><![CDATA[
#
# generated by slim for wlw at Mon Sep 09 09:09:01 AM PDT 2013
#
slim 2 appearance slim {
  instance displacement Simple_0 slim/shaders/bug_19displacementBounds/Simple_0 {
    attachmenttypes displacement
    creator {
      appearanceid 00000mu___ldZBWK
      container {slim internal palette}
      containerid 00000mu___FG85WK
      filename untitled
      label {untitled 3}
      session /seahome/charvey/maya/projects/RMS4_5Dev/scenes/bug_19displacementBounds.ma
      timestamp 1375921529
      translator slim
      workspace /seahome/wlw/maya/projects/default/RMSworkspace.ws
    }
    # start of Simple_0
    riattribute float displacementbound {
      label {Displacement Bound}
      description {This number represents the maximum displacement in shaderspace that your surface will undergo. Be very careful with this parameter as it can dramatically influence rendering times. In particular, make SURE to set this to 0 (zero) if you aren't performing any displacement.}
      range {0 100 .001}
      subtype vslider
      default 0
      value 1.000
    }
    # end of Simple_0
    collection void ImageFile_0 {
      state open
      parameter string ImageFile_0_File {
        label File
        description {Choose an image file.}
        subtype texture
        default {}
        value /seahome/charvey/Documents/dino_textures/ts_dispmap.tex
      }
    }
  }
}
]]></meta>
<meta id="slimtemplates">
  <template vendor="pixar" version="1">
    <fullname>pixar,F_ImageFile#1</fullname>
    <name>F_ImageFile</name>
    <usagecount>1</usagecount>
  </template>
  <template vendor="pixar" version="0">
    <fullname>pixar,SimpleDisplacement#0</fullname>
    <name>SimpleDisplacement</name>
    <usagecount>1</usagecount>
  </template>

</meta>
 */
/* slim defines ------------------------*/
#define SLIM_VERSION 1050
#define SLIM_CLIENTMODE_mtor 0
#define SLIM_CLIENTMODE_RenderMan_for_Maya  1
#define SLIM_CLIENTMODE SLIM_CLIENTMODE_RenderMan_for_Maya
#define SLIM_TYPEID_surface 0
#define SLIM_TYPEID_displacement 1
#define SLIM_TYPEID_volume 2
#define SLIM_TYPEID_light 3
#define SLIM_TYPEID_class 4
#define SLIM_TYPEID_imager 5
#define SLIM_SHADERTYPE displacement
#define SLIM_SHADERTYPEID SLIM_TYPEID_displacement
#define SLIM_INSTANCETYPE displacement
#define SLIM_INSTANCENAME Simple_0

/* includes ---------------------------------*/
#include "pxslRemap.h"
#include "pxslUtil.h"

/* template defines -----------------------*/

/* shader ----------------------------------*/
displacement SLIM_INSTANCENAME (


                 string  ImageFile_0_File = "/seahome/charvey/Documents/dino_textures/ts_dispmap.tex";
  uniform string _SlimAppLabel = "Simple_0";
  uniform string _SlimAppID = "00000mu___ldZBWK";
)
{
/* preamble end */



  /* static functions ---------------------------------(*/

	    void
	    pxslF_ImageFile ( uniform string File;
                        varying float DefaultValue;
			uniform float Channel;
			uniform float Invert;
			float Bias;
			float Gain;
                        float apply_sRGB;
			float SFilt;
			float TFilt;
			uniform string filter;
			uniform float lerp;
			point Pt;
			vector dPdu;
			vector dPdv;
			output float result;
			)
	    {
		if (File != "") { 
		    if (Channel < 4)
		    {
			result = float texture(File[Channel],
				xcomp(Pt), ycomp(Pt), 
				"swidth", SFilt,
				"twidth", TFilt,
				"filter", filter,
				"lerp", lerp,
                                "fill", DefaultValue);
		    }
		    else
		    {
			color c = color texture(File,
			    	     xcomp(Pt),
				     ycomp(Pt), 
				    "swidth", SFilt,
				    "twidth", TFilt,
				    "filter", filter,
				    "lerp", lerp);
			if(Channel == 4) /* luminance */
			{
			    result = pxslLuminance(c);
			}
			else
			if(Channel == 5) /* max */
			{
			    result = max( comp(c, 0),  comp(c, 1), comp(c, 2));
			}
			else
			if(Channel == 6) /* min */
			{
			    result = min( comp(c, 0),  comp(c, 1), comp(c, 2));
			}
			else
			if(Channel == 7) /* avg */
			{
			    result = (comp(c, 0) + comp(c, 1) + comp(c, 2)) / 3;
			}
		    }
		} else {
		    result = DefaultValue;
		}
		if(Invert != 0)
		{
		    result = 1 - result;
		}
                if (apply_sRGB == 1) 
                { 
                    uniform float A = 1./12.92;
                    uniform float B = 1./1.055;
                        result = result < .04045 ?
                            result * A : pow((result+.055) * B , 2.4);
                }
		result = pxslFloatBias(Bias, result);
		result = pxslFloatGain(Gain, result);
	    }
	

		void pxslST (
			  uniform float angle;
			  uniform float repeatS; uniform float repeatT;
			  uniform float offsetS; uniform float offsetT;
			  output point Q;
			  output vector dQu;
			  output vector dQv;
			  )
		{
		    extern float s, t, du, dv;

		    setxcomp(Q, repeatS * s + offsetS);
		    setycomp(Q, repeatT * t + offsetT);
		    setzcomp(Q, 0);

		    if(angle != 0)
			Q = rotate(Q, radians(angle), 
			    	    point(0,0,0), point(0,0,1)); 

		    dQu = vector Du(Q)*du;
		    dQv = vector Dv(Q)*dv;
		}
	    
  /*) end static functions ---------------------------- */

  /* dynamic functions ----------(*/
  /*) end dynamic functions --------------------------- */

  /* locals ------------------------------- */
  float tmp3;
  point tmp0;
  vector tmp1;
  vector tmp2;

  /* main body --------------------------(*/
  point PP = P;
  /* generate (all.1) ----------- */
  pxslST ( /* ST */
    0, /* Angle */
    1, /* S Repeats */
    1, /* T Repeats */
    0, /* S Offset */
    0, /* T Offset */
    tmp0, /*Q */
    tmp1, /*dQu */
    tmp2 /*dQv */
    );
  pxslF_ImageFile ( /* ImageFile_0 */
    ImageFile_0_File, /* File */
    1, /* Default Value */
    0, /* Channel */
    0, /* Invert */
    .5, /* Bias */
    .5, /* Gain */
    0, /* Linearize */
    1, /* S Filtering */
    1, /* T Filtering */
    "box", /* Filter */
    0, /* lerp */
    tmp0, /* Q */
    tmp1, /* dQu */
    tmp2, /* dQv */
    tmp3 /*result */
    );
  normal Nn = normalize(N);
  vector Nf = Nn * ( 1.000 * tmp3 ) /
              length(vtransform("shader", Nn));
  PP += Nf;
  if(1 != 0) { 
      normal deltaN = Nn - normalize(Ng);
      N = normalize(calculatenormal(PP)) + deltaN;
  } else {
      N = calculatenormal(PP);
  }
  if(1 != 0)
      P = PP;
  /*)*/
}

